//! Helpful types, mostly generated by the axum openapi codegen.

use std::{fmt::Display, ops::Deref, str::FromStr};

use iceberg::TableIdent;
use iceberg_ext::configs::ParseFromStr;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use typed_builder::TypedBuilder;

pub(crate) const NAMESPACE_DELIMITER: &str = "\u{1f}";

/// A single referenced view within a query.
#[derive(Debug, Clone, PartialEq)]
pub struct ReferencingView(TableIdent);

impl ReferencingView {
    #[must_use]
    pub fn new(ident: TableIdent) -> Self {
        Self(ident)
    }

    #[must_use]
    pub fn into_inner(self) -> TableIdent {
        self.0
    }
}

impl Deref for ReferencingView {
    type Target = TableIdent;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<TableIdent> for ReferencingView {
    fn from(ident: TableIdent) -> Self {
        Self(ident)
    }
}

impl FromStr for ReferencingView {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let segments: Vec<_> = s.split(NAMESPACE_DELIMITER).collect();
        TableIdent::from_strs(segments)
            .map(ReferencingView)
            .map_err(|e| e.to_string())
    }
}

impl Display for ReferencingView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for segment in self.0.namespace.iter() {
            write!(f, "{segment}{NAMESPACE_DELIMITER}")?;
        }
        write!(f, "{}", self.0.name)
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct ReferencedByQuery(Vec<ReferencingView>);

impl ReferencedByQuery {
    #[must_use]
    pub fn into_inner(self) -> Vec<ReferencingView> {
        self.0
    }
}

impl From<Vec<ReferencingView>> for ReferencedByQuery {
    fn from(views: Vec<ReferencingView>) -> Self {
        Self(views)
    }
}

impl From<Vec<TableIdent>> for ReferencedByQuery {
    fn from(idents: Vec<TableIdent>) -> Self {
        Self(idents.into_iter().map(ReferencingView::from).collect())
    }
}

impl Deref for ReferencedByQuery {
    type Target = [ReferencingView];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<'de> Deserialize<'de> for ReferencedByQuery {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let referenced_by_raw = String::deserialize(deserializer)?;
        if referenced_by_raw.is_empty() {
            return Ok(ReferencedByQuery(vec![]));
        }

        let referenced_by = referenced_by_raw
            .split(',')
            .map(|node| {
                node.parse::<ReferencingView>()
                    .map_err(serde::de::Error::custom)
            })
            .collect::<Result<Vec<_>, _>>()?;

        Ok(ReferencedByQuery(referenced_by))
    }
}

impl Serialize for ReferencedByQuery {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let referenced_by = self
            .0
            .iter()
            .map(ToString::to_string)
            .collect::<Vec<_>>()
            .join(",");
        serializer.serialize_str(&referenced_by)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Deserialize)]
pub struct Prefix(pub(crate) String);

impl Prefix {
    #[inline]
    #[must_use]
    pub fn as_str(&self) -> &str {
        &self.0
    }

    #[inline]
    #[must_use]
    pub fn into_string(self) -> String {
        self.0
    }
}

impl From<String> for Prefix {
    fn from(s: String) -> Self {
        Self(s)
    }
}

impl From<&str> for Prefix {
    fn from(s: &str) -> Self {
        Self(s.to_owned())
    }
}

impl AsRef<str> for Prefix {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
#[non_exhaustive]
pub enum PageToken {
    /// The value is present and not ""
    Present(String),
    /// The value is not present
    NotSpecified,
    /// Specified but empty
    #[default]
    // Empty indicates pagination is supported by the client, hence its default.
    Empty,
}

impl From<Option<String>> for PageToken {
    fn from(opt: Option<String>) -> Self {
        match opt {
            Some(s) => PageToken::Present(s),
            None => PageToken::NotSpecified,
        }
    }
}

impl PageToken {
    #[must_use]
    pub fn as_option(&self) -> Option<&str> {
        match self {
            PageToken::Present(s) => Some(s),
            PageToken::NotSpecified | PageToken::Empty => None,
        }
    }

    #[inline]
    #[must_use]
    pub fn new_present(s: String) -> Self {
        if s.is_empty() {
            PageToken::Empty
        } else {
            PageToken::Present(s)
        }
    }

    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        matches!(self, PageToken::Empty)
    }

    #[inline]
    #[must_use]
    pub fn is_unspecified(&self) -> bool {
        matches!(self, PageToken::NotSpecified)
    }

    #[inline]
    #[must_use]
    pub fn skip_serialize(&self) -> bool {
        matches!(self, PageToken::NotSpecified)
    }
}

impl<'de> Deserialize<'de> for PageToken {
    fn deserialize<D>(deserializer: D) -> Result<PageToken, D::Error>
    where
        D: Deserializer<'de>,
    {
        let opt = Option::<String>::deserialize(deserializer)?;
        match opt {
            Some(s) if !s.is_empty() => Ok(PageToken::Present(s)),
            Some(_) => Ok(PageToken::Empty),
            None => Ok(PageToken::NotSpecified),
        }
    }
}

impl Serialize for PageToken {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            PageToken::Present(s) => serializer.serialize_str(s),
            PageToken::NotSpecified => serializer.serialize_none(),
            PageToken::Empty => serializer.serialize_str(""),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
#[non_exhaustive]
pub enum NextPageToken {
    /// The value is present and not "" and not "null"
    NextToken(String),
    /// The value is not present
    Finished,
    /// The server does not support pagination
    /// This omits the `nextPageToken` field in the response
    NotSupported,
}

impl NextPageToken {
    #[inline]
    #[must_use]
    pub fn new_finished() -> Self {
        NextPageToken::Finished
    }

    #[inline]
    #[must_use]
    pub fn new_not_supported() -> Self {
        NextPageToken::NotSupported
    }

    #[inline]
    #[must_use]
    pub fn new_next_token(s: String) -> Self {
        if s.is_empty() {
            NextPageToken::Finished
        } else if s == "null" {
            NextPageToken::NotSupported
        } else {
            NextPageToken::NextToken(s)
        }
    }

    #[inline]
    #[must_use]
    pub fn is_unsupported(&self) -> bool {
        matches!(self, NextPageToken::NotSupported)
    }

    #[inline]
    #[must_use]
    pub fn is_finished(&self) -> bool {
        matches!(self, NextPageToken::Finished)
    }

    #[inline]
    #[must_use]
    pub fn skip_serialize(&self) -> bool {
        matches!(self, NextPageToken::NotSupported)
    }
}

impl Serialize for NextPageToken {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            NextPageToken::NextToken(s) => serializer.serialize_str(s),
            NextPageToken::Finished => serializer.serialize_str("null"),
            NextPageToken::NotSupported => serializer.serialize_none(),
        }
    }
}

impl<'de> Deserialize<'de> for NextPageToken {
    fn deserialize<D>(deserializer: D) -> Result<NextPageToken, D::Error>
    where
        D: Deserializer<'de>,
    {
        let opt = Option::<String>::deserialize(deserializer)?;
        match opt {
            Some(s) if !s.is_empty() => Ok(NextPageToken::NextToken(s)),
            Some(s) if s == "null" => Ok(NextPageToken::NotSupported),
            Some(_) => Ok(NextPageToken::Finished),
            None => Ok(NextPageToken::NotSupported),
        }
    }
}

fn true_fn() -> bool {
    true
}

#[derive(Debug, Clone, Deserialize, PartialEq, Eq, TypedBuilder)]
#[serde(rename_all = "camelCase")]
pub struct DropParams {
    #[serde(deserialize_with = "deserialize_bool", default = "true_fn")]
    pub purge_requested: bool,
    #[serde(deserialize_with = "deserialize_bool", default)]
    pub force: bool,
}

pub(crate) fn deserialize_bool<'de, D>(deserializer: D) -> Result<bool, D::Error>
where
    D: Deserializer<'de>,
{
    let s: String = String::deserialize(deserializer)?;
    <bool>::parse_value(s.as_str()).map_err(serde::de::Error::custom)
}

#[cfg(test)]
mod tests {
    use axum::{Router, body::Body, extract::Query, http::Request, routing::get};
    use http_body_util::BodyExt;
    use tower::ServiceExt;

    use super::*;

    #[test]
    fn test_drop_parms() {
        let query = "purgeRequested=true";
        let params: DropParams = serde_urlencoded::from_str(query).unwrap();
        assert_eq!(
            params,
            DropParams {
                purge_requested: true,
                force: false,
            }
        );

        let query = "purgeRequested=True";
        let params: DropParams = serde_urlencoded::from_str(query).unwrap();
        assert_eq!(
            params,
            DropParams {
                purge_requested: true,
                force: false,
            }
        );

        let empty_query = "";
        let empty_params: DropParams = serde_urlencoded::from_str(empty_query).unwrap();
        assert_eq!(
            empty_params,
            DropParams {
                purge_requested: true,
                force: false,
            }
        );

        let query = "force=true&purgeRequested=true";
        let params: DropParams = serde_urlencoded::from_str(query).unwrap();
        assert_eq!(
            params,
            DropParams {
                purge_requested: true,
                force: true,
            }
        );
        let query = "force=true&purgeRequested=false";
        let params: DropParams = serde_urlencoded::from_str(query).unwrap();
        assert_eq!(
            params,
            DropParams {
                purge_requested: false,
                force: true,
            }
        );
    }

    #[tokio::test]
    async fn test_page_token_de() {
        async fn send_request_get_body(query: &str) -> String {
            let body = app()
                .oneshot(
                    Request::builder()
                        .uri(format!("/?{query}"))
                        .body(Body::empty())
                        .unwrap(),
                )
                .await
                .unwrap();
            let bytes = body.collect().await.unwrap().to_bytes();
            String::from_utf8(bytes.to_vec()).unwrap()
        }

        fn app() -> Router {
            Router::new().route("/", get(handler))
        }

        async fn handler(Query(params): Query<Params>) -> String {
            format!("{params:?}")
        }

        #[derive(Debug, Clone, PartialEq, serde::Deserialize)]
        #[serde(rename_all = "camelCase")]
        struct Params {
            page_token: PageToken,
            #[serde(skip_serializing_if = "Option::is_none")]
            parent: Option<String>,
        }

        assert_eq!(
            send_request_get_body("").await,
            r"Params { page_token: NotSpecified, parent: None }"
        );

        assert_eq!(
            send_request_get_body("parent=").await,
            r#"Params { page_token: NotSpecified, parent: Some("") }"#
        );

        assert_eq!(
            send_request_get_body("pageToken=123&foo").await,
            r#"Params { page_token: Present("123"), parent: None }"#
        );

        assert_eq!(
            send_request_get_body("pageToken&foo").await,
            r"Params { page_token: Empty, parent: None }"
        );

        assert_eq!(
            send_request_get_body("pageToken=&foo").await,
            r"Params { page_token: Empty, parent: None }"
        );
    }

    #[test]
    fn test_referenced_by_query_de_ser() {
        let s = "prod\u{1f}analytics\u{1f}quarterly_view";
        let referenced_by: ReferencedByQuery =
            serde_json::from_value(serde_json::json!(s)).unwrap();

        assert_eq!(referenced_by.len(), 1);
        assert_eq!(referenced_by[0].name, "quarterly_view");
        assert_eq!(
            referenced_by[0].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }

    #[test]
    fn test_referenced_by_query_with_comma_separated_referencing_views_de_ser() {
        let s = "prod\u{1f}analytics\u{1f}quarterly_view,prod\u{1f}analytics\u{1f}monthly_view";
        let referenced_by: ReferencedByQuery =
            serde_json::from_value(serde_json::json!(s)).unwrap();

        assert_eq!(referenced_by.len(), 2);
        assert_eq!(referenced_by[0].name, "quarterly_view");
        assert_eq!(
            referenced_by[0].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );
        assert_eq!(referenced_by[1].name, "monthly_view");
        assert_eq!(
            referenced_by[1].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }

    #[test]
    fn test_referenced_by_query_with_space_de_ser() {
        let s = "prod\u{1f}analytics\u{1f}quarterly view";
        let referenced_by: ReferencedByQuery =
            serde_json::from_value(serde_json::json!(s)).unwrap();

        assert_eq!(referenced_by.len(), 1);
        assert_eq!(referenced_by[0].name, "quarterly view");

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }

    #[test]
    fn test_referenced_by_query_with_plus_de_ser() {
        let s = "prod\u{1f}analytics\u{1f}quarterly+view";
        let referenced_by: ReferencedByQuery =
            serde_json::from_value(serde_json::json!(s)).unwrap();

        assert_eq!(referenced_by.len(), 1);
        assert_eq!(referenced_by[0].name, "quarterly+view");

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }
}
