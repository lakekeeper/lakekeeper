//! Helpful types, mostly generated by the axum openapi codegen.

use std::ops::Deref;

use iceberg::TableIdent;
use iceberg_ext::configs::ParseFromStr;
use percent_encoding::percent_decode_str;
use serde::{Deserialize, Deserializer, Serialize, Serializer, de::IntoDeserializer};
use typed_builder::TypedBuilder;

pub(crate) const NAMESPACE_DELIMITER: &str = "\u{1f}";

/// A single referenced view within a query.
#[derive(Debug, Clone, PartialEq)]
pub struct ReferencingView(TableIdent);

impl ReferencingView {
    #[must_use]
    pub fn new(ident: TableIdent) -> Self {
        Self(ident)
    }

    #[must_use]
    pub fn into_inner(self) -> TableIdent {
        self.0
    }
}

impl Deref for ReferencingView {
    type Target = TableIdent;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<TableIdent> for ReferencingView {
    fn from(ident: TableIdent) -> Self {
        Self(ident)
    }
}

impl<'de> Deserialize<'de> for ReferencingView {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let data = String::deserialize(deserializer)?;
        if data.is_empty() {
            return Ok(ReferencingView(
                TableIdent::from_strs(Vec::<String>::new()).map_err(serde::de::Error::custom)?,
            ));
        }
        let decoded = percent_decode_str(&data)
            .decode_utf8()
            .map_err(|e| serde::de::Error::custom(format!("Failed to URL-decode: {}", e)))?;

        let segments: Vec<_> = decoded.split(NAMESPACE_DELIMITER).collect();

        Ok(ReferencingView(
            TableIdent::from_strs(segments).map_err(|e| serde::de::Error::custom(e))?,
        ))
    }
}

impl Serialize for ReferencingView {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let namespace_data = self.0.namespace().to_url_string();
        let name = self.0.name();

        let referenced_by = format!("{}{}{}", namespace_data, NAMESPACE_DELIMITER, name)
            .replace(" ", "%20")
            .replace(",", "%2C")
            .replace(NAMESPACE_DELIMITER, "%1F");
        serializer.serialize_str(&referenced_by)
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct ReferencedByQuery(Vec<ReferencingView>);

impl ReferencedByQuery {
    #[must_use]
    pub fn into_inner(self) -> Vec<ReferencingView> {
        self.0
    }
}

impl From<Vec<TableIdent>> for ReferencedByQuery {
    fn from(idents: Vec<TableIdent>) -> Self {
        Self(idents.into_iter().map(ReferencingView::from).collect())
    }
}

impl Deref for ReferencedByQuery {
    type Target = [ReferencingView];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<'de> Deserialize<'de> for ReferencedByQuery {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct ReferencedByQueryVisitor;

        impl<'de> serde::de::Visitor<'de> for ReferencedByQueryVisitor {
            type Value = ReferencedByQuery;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("a string or map containing referenced views")
            }

            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                if value.is_empty() {
                    return Ok(ReferencedByQuery(vec![]));
                }

                let referencing_views = value
                    .split(',')
                    .map(|encoded_view_data| {
                        let inner_deserializer = encoded_view_data.into_deserializer();
                        ReferencingView::deserialize(inner_deserializer)
                    })
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(ReferencedByQuery(referencing_views))
            }
        }

        deserializer.deserialize_str(ReferencedByQueryVisitor)
    }
}

impl Serialize for ReferencedByQuery {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let referenced_by = self
            .0
            .iter()
            .map(|view| {
                serde_json::to_value(view)
                    .unwrap()
                    .as_str()
                    .unwrap()
                    .to_string()
            })
            .collect::<Vec<_>>()
            .join(",");
        serializer.serialize_str(&referenced_by)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Deserialize)]
pub struct Prefix(pub(crate) String);

impl Prefix {
    #[inline]
    #[must_use]
    pub fn as_str(&self) -> &str {
        &self.0
    }

    #[inline]
    #[must_use]
    pub fn into_string(self) -> String {
        self.0
    }
}

impl From<String> for Prefix {
    fn from(s: String) -> Self {
        Self(s)
    }
}

impl From<&str> for Prefix {
    fn from(s: &str) -> Self {
        Self(s.to_owned())
    }
}

impl AsRef<str> for Prefix {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
#[non_exhaustive]
pub enum PageToken {
    /// The value is present and not ""
    Present(String),
    /// The value is not present
    NotSpecified,
    /// Specified but empty
    #[default]
    // Empty indicates pagination is supported by the client, hence its default.
    Empty,
}

impl From<Option<String>> for PageToken {
    fn from(opt: Option<String>) -> Self {
        match opt {
            Some(s) => PageToken::Present(s),
            None => PageToken::NotSpecified,
        }
    }
}

impl PageToken {
    #[must_use]
    pub fn as_option(&self) -> Option<&str> {
        match self {
            PageToken::Present(s) => Some(s),
            PageToken::NotSpecified | PageToken::Empty => None,
        }
    }

    #[inline]
    #[must_use]
    pub fn new_present(s: String) -> Self {
        if s.is_empty() {
            PageToken::Empty
        } else {
            PageToken::Present(s)
        }
    }

    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        matches!(self, PageToken::Empty)
    }

    #[inline]
    #[must_use]
    pub fn is_unspecified(&self) -> bool {
        matches!(self, PageToken::NotSpecified)
    }

    #[inline]
    #[must_use]
    pub fn skip_serialize(&self) -> bool {
        matches!(self, PageToken::NotSpecified)
    }
}

impl<'de> Deserialize<'de> for PageToken {
    fn deserialize<D>(deserializer: D) -> Result<PageToken, D::Error>
    where
        D: Deserializer<'de>,
    {
        let opt = Option::<String>::deserialize(deserializer)?;
        match opt {
            Some(s) if !s.is_empty() => Ok(PageToken::Present(s)),
            Some(_) => Ok(PageToken::Empty),
            None => Ok(PageToken::NotSpecified),
        }
    }
}

impl Serialize for PageToken {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            PageToken::Present(s) => serializer.serialize_str(s),
            PageToken::NotSpecified => serializer.serialize_none(),
            PageToken::Empty => serializer.serialize_str(""),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
#[non_exhaustive]
pub enum NextPageToken {
    /// The value is present and not "" and not "null"
    NextToken(String),
    /// The value is not present
    Finished,
    /// The server does not support pagination
    /// This omits the `nextPageToken` field in the response
    NotSupported,
}

impl NextPageToken {
    #[inline]
    #[must_use]
    pub fn new_finished() -> Self {
        NextPageToken::Finished
    }

    #[inline]
    #[must_use]
    pub fn new_not_supported() -> Self {
        NextPageToken::NotSupported
    }

    #[inline]
    #[must_use]
    pub fn new_next_token(s: String) -> Self {
        if s.is_empty() {
            NextPageToken::Finished
        } else if s == "null" {
            NextPageToken::NotSupported
        } else {
            NextPageToken::NextToken(s)
        }
    }

    #[inline]
    #[must_use]
    pub fn is_unsupported(&self) -> bool {
        matches!(self, NextPageToken::NotSupported)
    }

    #[inline]
    #[must_use]
    pub fn is_finished(&self) -> bool {
        matches!(self, NextPageToken::Finished)
    }

    #[inline]
    #[must_use]
    pub fn skip_serialize(&self) -> bool {
        matches!(self, NextPageToken::NotSupported)
    }
}

impl Serialize for NextPageToken {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            NextPageToken::NextToken(s) => serializer.serialize_str(s),
            NextPageToken::Finished => serializer.serialize_str("null"),
            NextPageToken::NotSupported => serializer.serialize_none(),
        }
    }
}

impl<'de> Deserialize<'de> for NextPageToken {
    fn deserialize<D>(deserializer: D) -> Result<NextPageToken, D::Error>
    where
        D: Deserializer<'de>,
    {
        let opt = Option::<String>::deserialize(deserializer)?;
        match opt {
            Some(s) if !s.is_empty() => Ok(NextPageToken::NextToken(s)),
            Some(s) if s == "null" => Ok(NextPageToken::NotSupported),
            Some(_) => Ok(NextPageToken::Finished),
            None => Ok(NextPageToken::NotSupported),
        }
    }
}

fn true_fn() -> bool {
    true
}

#[derive(Debug, Clone, Deserialize, PartialEq, Eq, TypedBuilder)]
#[serde(rename_all = "camelCase")]
pub struct DropParams {
    #[serde(deserialize_with = "deserialize_bool", default = "true_fn")]
    pub purge_requested: bool,
    #[serde(deserialize_with = "deserialize_bool", default)]
    pub force: bool,
}

pub(crate) fn deserialize_bool<'de, D>(deserializer: D) -> Result<bool, D::Error>
where
    D: Deserializer<'de>,
{
    let s: String = String::deserialize(deserializer)?;
    <bool>::parse_value(s.as_str()).map_err(serde::de::Error::custom)
}

#[cfg(test)]
mod tests {
    use axum::{Router, body::Body, extract::Query, http::Request, routing::get};
    use http_body_util::BodyExt;
    use serde::de::value::{Error, StrDeserializer};
    use tower::ServiceExt;

    use super::*;

    #[test]
    fn test_drop_parms() {
        let query = "purgeRequested=true";
        let params: DropParams = serde_urlencoded::from_str(query).unwrap();
        assert_eq!(
            params,
            DropParams {
                purge_requested: true,
                force: false,
            }
        );

        let query = "purgeRequested=True";
        let params: DropParams = serde_urlencoded::from_str(query).unwrap();
        assert_eq!(
            params,
            DropParams {
                purge_requested: true,
                force: false,
            }
        );

        let empty_query = "";
        let empty_params: DropParams = serde_urlencoded::from_str(empty_query).unwrap();
        assert_eq!(
            empty_params,
            DropParams {
                purge_requested: true,
                force: false,
            }
        );

        let query = "force=true&purgeRequested=true";
        let params: DropParams = serde_urlencoded::from_str(query).unwrap();
        assert_eq!(
            params,
            DropParams {
                purge_requested: true,
                force: true,
            }
        );
        let query = "force=true&purgeRequested=false";
        let params: DropParams = serde_urlencoded::from_str(query).unwrap();
        assert_eq!(
            params,
            DropParams {
                purge_requested: false,
                force: true,
            }
        );
    }

    #[tokio::test]
    async fn test_page_token_de() {
        async fn send_request_get_body(query: &str) -> String {
            let body = app()
                .oneshot(
                    Request::builder()
                        .uri(format!("/?{query}"))
                        .body(Body::empty())
                        .unwrap(),
                )
                .await
                .unwrap();
            let bytes = body.collect().await.unwrap().to_bytes();
            String::from_utf8(bytes.to_vec()).unwrap()
        }

        fn app() -> Router {
            Router::new().route("/", get(handler))
        }

        async fn handler(Query(params): Query<Params>) -> String {
            format!("{params:?}")
        }

        #[derive(Debug, Clone, PartialEq, serde::Deserialize)]
        #[serde(rename_all = "camelCase")]
        struct Params {
            page_token: PageToken,
            #[serde(skip_serializing_if = "Option::is_none")]
            parent: Option<String>,
        }

        assert_eq!(
            send_request_get_body("").await,
            r"Params { page_token: NotSpecified, parent: None }"
        );

        assert_eq!(
            send_request_get_body("parent=").await,
            r#"Params { page_token: NotSpecified, parent: Some("") }"#
        );

        assert_eq!(
            send_request_get_body("pageToken=123&foo").await,
            r#"Params { page_token: Present("123"), parent: None }"#
        );

        assert_eq!(
            send_request_get_body("pageToken&foo").await,
            r"Params { page_token: Empty, parent: None }"
        );

        assert_eq!(
            send_request_get_body("pageToken=&foo").await,
            r"Params { page_token: Empty, parent: None }"
        );
    }

    #[test]
    fn test_referenced_by_query_single_referencing_view_de_ser() {
        let s = "prod%1Fanalytics%1Fquarterly_view";
        let deserializer: StrDeserializer<'_, Error> = s.into_deserializer();
        let referenced_by: ReferencedByQuery =
            ReferencedByQuery::deserialize(deserializer).unwrap();

        assert_eq!(referenced_by.len(), 1);
        assert_eq!(referenced_by[0].name, "quarterly_view");
        assert_eq!(
            referenced_by[0].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }

    #[test]
    fn test_referenced_by_query_with_comma_separated_referencing_views_de_ser() {
        let s = "prod%1Fanalytics%1Fquarterly_view,prod%1Fanalytics%1Fmonthly_view";
        let deserializer: StrDeserializer<'_, Error> = s.into_deserializer();
        let referenced_by: ReferencedByQuery =
            ReferencedByQuery::deserialize(deserializer).unwrap();

        assert_eq!(referenced_by.len(), 2);
        assert_eq!(referenced_by[0].name, "quarterly_view");
        assert_eq!(
            referenced_by[0].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );
        assert_eq!(referenced_by[1].name, "monthly_view");
        assert_eq!(
            referenced_by[1].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }

    #[test]
    fn test_referenced_by_query_with_space_in_referencing_view_de_ser() {
        let s = "prod%1Fanalytics%1Fquarterly%20view";
        let deserializer: StrDeserializer<'_, Error> = s.into_deserializer();
        let referenced_by: ReferencedByQuery =
            ReferencedByQuery::deserialize(deserializer).unwrap();

        assert_eq!(referenced_by.len(), 1);
        assert_eq!(referenced_by[0].name, "quarterly view");

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }

    #[test]
    fn test_referenced_by_query_with_plus_in_referencing_view_de_ser() {
        let s = "prod%1Fanalytics%1Fquarterly+view";
        let deserializer: StrDeserializer<'_, Error> = s.into_deserializer();
        let referenced_by: ReferencedByQuery =
            ReferencedByQuery::deserialize(deserializer).unwrap();

        assert_eq!(referenced_by.len(), 1);
        assert_eq!(referenced_by[0].name, "quarterly+view");

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }

    #[test]
    fn test_referenced_by_query_with_comma_in_referencing_view_de_ser() {
        let s = "prod%1Fanalytics%1Fquarterly_view,prod%1Fanalytics%1Fmonthly%2Cview";
        let deserializer: StrDeserializer<'_, Error> = s.into_deserializer();
        let referenced_by: ReferencedByQuery =
            ReferencedByQuery::deserialize(deserializer).unwrap();

        assert_eq!(referenced_by.len(), 2);
        assert_eq!(referenced_by[0].name, "quarterly_view");
        assert_eq!(
            referenced_by[0].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );
        assert_eq!(referenced_by[1].name, "monthly,view");
        assert_eq!(
            referenced_by[1].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s));
    }

    #[test]
    fn test_referenced_by_query_with_lowercase_namespace_separator_de_ser() {
        let s = "prod%1fanalytics%1fquarterly_view";
        let deserializer: StrDeserializer<'_, Error> = s.into_deserializer();
        let referenced_by: ReferencedByQuery =
            ReferencedByQuery::deserialize(deserializer).unwrap();

        assert_eq!(referenced_by.len(), 1);
        assert_eq!(referenced_by[0].name, "quarterly_view");
        assert_eq!(
            referenced_by[0].namespace.clone().inner(),
            vec!["prod", "analytics"]
        );

        let serialized = serde_json::to_value(&referenced_by).unwrap();
        assert_eq!(serialized, serde_json::json!(s.replace("%1f", "%1F")));
    }
}
